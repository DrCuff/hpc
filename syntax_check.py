import re
import sys
import subprocess

# Cuff autogenerated via a GPT...


# Extend known SBATCH options with expected value types
# Mapping: option -> (type, validator regex or function, description)
OPTION_SPECS = {
    '--job-name': ('string', None, 'Job name (no spaces)'),
    '-J': ('string', None, 'Job name (alias of --job-name)'),
    '--partition': ('partition', None, 'Partition name'),
    '-p': ('partition', None, 'Partition name'),
    '--nodes': ('int', r'^\d+$', 'Number of nodes'),
    '-N': ('int', r'^\d+$', 'Number of nodes'),
    '--ntasks': ('int', r'^\d+$', 'Number of tasks'),
    '-n': ('int', r'^\d+$', 'Number of tasks'),
    '--ntasks-per-node': ('int', r'^\d+$', 'Tasks per node'),
    '--cpus-per-task': ('int', r'^\d+$', 'CPUs per task'),
    '--threads-per-core': ('int', r'^\d+$', 'Threads per core'),
    '--time': ('time', r'^(\d+(-\d+)?:)?\d{1,2}:\d{2}(:\d{2})?$', 'Time limit [[days-]hours:]minutes[:seconds]'),
    '-t': ('time', r'^(\d+(-\d+)?:)?\d{1,2}:\d{2}(:\d{2})?$', 'Time limit'),
    '--output': ('path', None, 'Standard output file path'),
    '-o': ('path', None, 'Standard output file path'),
    '--error': ('path', None, 'Standard error file path'),
    '-e': ('path', None, 'Standard error file path'),
    '--mail-type': ('enum', {'BEGIN','END','FAIL','REQUEUE','ALL'}, 'Mail notification type'),
    '--mail-user': ('email', r'^[^@\s]+@[^@\s]+\.[^@\s]+$', 'Email address for notifications'),
    '--array': ('array', r'^\d+([-,]\d+)*(%\d+)?$', 'Job array specification'),
    '--dependency': ('dependency', r'^(afterok|afterany|afternotok|after):\d+(,\d+)*(%\d+)?$', 'Job dependency'),
    '--mem': ('mem', r'^\d+[KMG]?$', 'Memory per node'),
    '--mem-per-cpu': ('mem', r'^\d+[KMG]?$', 'Memory per CPU'),
    '--constraint': ('string', None, 'Feature constraints'),
    '--gres': ('gres', r'^[A-Za-z]+:\d+(\.[0-9]+)?[KMG]?(,[A-Za-z]+:\d+(\.[0-9]+)?[KMG]?)*$', 'Generic resources (e.g., gpu:2,mem:4G)'),
    '--export': ('export', r'^(NONE|ALL|[A-Za-z_]\w*(=[^,]+)?(,[A-Za-z_]\w*(=[^,]+)?)*$)', 'Environment variable export spec'),
    '--qos': ('string', None, 'Quality of Service'),
    '--account': ('string', None, 'Account name for billing'),
    '--licenses': ('licenses', r'^[A-Za-z]+(:\d+){1,2}(,[A-Za-z]+(:\d+){1,2})*$', 'License usage spec (e.g., matlab:1:2)'),
}

SBATCH_LINE_RE = re.compile(r"^#SBATCH\s+(.*)")
OPTION_RE = re.compile(r"^(?P<opt>--?[A-Za-z][A-Za-z-]*)(=(?P<val>.*))?$")


def get_available_partitions():
    try:
        out = subprocess.check_output(['sinfo', '--noheader', '-o', '%P'], universal_newlines=True)
        parts = {p.strip().strip('*') for p in out.splitlines() if p.strip()}
        return parts
    except Exception:
        return None


def validate_option(opt, val, line_no, errors, seen_opts, parsed_opts):
    # Check duplicates
    if opt in seen_opts:
        errors.append((line_no, f'Duplicate SBATCH option: {opt}'))
    seen_opts.add(opt)

    spec = OPTION_SPECS.get(opt)
    if not spec:
        errors.append((line_no, f'Unknown SBATCH option: {opt}'))
        return

    val_type, validator, description = spec
    if val is None:
        errors.append((line_no, f'Missing value for option: {opt} ({description})'))
        return

    val = val.strip()
    if not val:
        errors.append((line_no, f'Empty value for option: {opt}'))
        return

    parsed_opts[opt] = val

    if val_type in ('int', 'time', 'mem', 'array', 'dependency', 'email', 'gres', 'export', 'licenses'):
        if isinstance(validator, dict):
            if val.upper() not in validator:
                errors.append((line_no, f'Invalid value for {opt}: {val} (expected one of {sorted(validator)})'))
        else:
            if not re.match(validator, val):
                errors.append((line_no, f'Invalid format for {opt}: {val} (expected {description})'))

    # Validate partition against sinfo
    if val_type == 'partition':
        parts = get_available_partitions()
        if parts is not None and val not in parts:
            errors.append((line_no, f'Partition "{val}" not found (available: {sorted(parts)})'))


def cross_validate(parsed_opts, errors):
    # Task vs. CPU vs. threads
    try:
        ntasks = int(parsed_opts.get('--ntasks') or parsed_opts.get('-n', 0))
        nodes = int(parsed_opts.get('--nodes') or parsed_opts.get('-N', 1))
        cpus = int(parsed_opts.get('--cpus-per-task', 1))
        threads = int(parsed_opts.get('--threads-per-core', 1))
        ntasks_per_node = int(parsed_opts.get('--ntasks-per-node', 0))

        if ntasks > nodes * ntasks_per_node > 0 and ntasks_per_node * nodes < ntasks:
            errors.append((0, f'--ntasks ({ntasks}) exceeds --ntasks-per-node*--nodes ({ntasks_per_node*nodes})'))
        if ntasks > nodes * cpus:
            errors.append((0, f'--ntasks ({ntasks}) exceeds --nodes*--cpus-per-task ({nodes*cpus})'))
        if threads > cpus:
            errors.append((0, f'--threads-per-core ({threads}) exceeds --cpus-per-task ({cpus})'))
    except ValueError:
        pass

    # Dependency vs array mutually allowed â€” no conflict

    # QoS validity (optional sinfo check)
    # Could implement: subprocess.check_output(['sacctmgr', 'show', 'qos'])


def check_sbatch_script(lines):
    errors = []
    seen_opts = set()
    parsed_opts = {}
    for idx, line in enumerate(lines, start=1):
        m = SBATCH_LINE_RE.match(line)
        if not m:
            continue
        directive = m.group(1).strip()
        if not directive:
            errors.append((idx, 'Empty #SBATCH directive'))
            continue

        m2 = OPTION_RE.match(directive)
        if not m2:
            errors.append((idx, f'Cannot parse directive: {directive}'))
            continue

        opt = m2.group('opt')
        val = m2.group('val')
        if val is None and ' ' in directive:
            parts = directive.split(None, 1)
            opt, val = parts[0], parts[1]

        validate_option(opt, val, idx, errors, seen_opts, parsed_opts)

    cross_validate(parsed_opts, errors)
    return errors


def main():
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <sbatch_script>")
        sys.exit(1)

    path = sys.argv[1]
    try:
        with open(path) as f:
            lines = f.readlines()
    except OSError as e:
        print(f"Error opening file: {e}")
        sys.exit(1)

    errors = check_sbatch_script(lines)
    if errors:
        print("Syntax issues found in SBATCH script:")
        for lineno, msg in errors:
            prefix = f"Line {lineno}" if lineno > 0 else "Cross-check"
            print(f"  {prefix}: {msg}")
        sys.exit(2)
    else:
        print("No syntax issues detected.")
        sys.exit(0)

if __name__ == '__main__':
    main()
